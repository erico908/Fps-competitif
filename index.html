<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Test FPS simple</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let keys = {};
let yaw = 0, pitch = 0;
let dragging = false;
let lastX, lastY;
let velocityY = 0;
let onGround = true;

init();
animate();

function init() {
    // Scène + caméra
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);

    // Rendu
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lumières
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    let light = new THREE.DirectionalLight(0xffffff, 0.5);
    light.position.set(5, 10, 5);
    scene.add(light);

    // Sol
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Événements clavier
    document.addEventListener('keydown', (e) => keys[e.code] = true);
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    // Souris (rotation caméra)
    document.addEventListener('mousedown', (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    document.addEventListener('mouseup', () => dragging = false);
    document.addEventListener('mousemove', (e) => {
        if (dragging) {
            yaw -= (e.clientX - lastX) * 0.002;
            pitch -= (e.clientY - lastY) * 0.002;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            camera.rotation.set(pitch, yaw, 0);
            lastX = e.clientX;
            lastY = e.clientY;
        }
    });

    // Ajustement taille fenêtre
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function animate() {
    requestAnimationFrame(animate);

    let speed = 0.2;
    let forward = (keys["KeyW"] ? 1 : 0) - (keys["KeyS"] ? 1 : 0);
    let strafe = (keys["KeyD"] ? 1 : 0) - (keys["KeyA"] ? 1 : 0);

    // Déplacement horizontal
    let forwardVec = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).multiplyScalar(forward * speed);
    let strafeVec = new THREE.Vector3(Math.sin(yaw + Math.PI/2), 0, Math.cos(yaw + Math.PI/2)).multiplyScalar(strafe * speed);
    camera.position.add(forwardVec);
    camera.position.add(strafeVec);

    // Gravité & saut
    if (onGround && keys["Space"]) {
        velocityY = 0.3; // force du saut
        onGround = false;
    }
    velocityY -= 0.01; // gravité
    camera.position.y += velocityY;

    if (camera.position.y <= 2) {
        camera.position.y = 2;
        velocityY = 0;
        onGround = true;
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>
