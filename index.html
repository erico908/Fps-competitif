<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>FPS libre</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 20px;
      font-family: Arial, sans-serif;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="overlay">Appuie sur une touche pour commencer</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
let camera, scene, renderer;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let prevTime = performance.now();
let pitchObject, yawObject;
let pointerLocked = false;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  pitchObject = new THREE.Object3D();
  pitchObject.add(camera);

  yawObject = new THREE.Object3D();
  yawObject.position.y = 2;
  yawObject.add(pitchObject);

  scene.add(yawObject);

  // Sol
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshPhongMaterial({ color: 0x228B22 })
  );
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Murs
  const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
  const walls = [
    { pos: [0,2,-10], size:[20,4,0.5] },
    { pos: [0,2,10],  size:[20,4,0.5] },
    { pos: [-10,2,0], size:[0.5,4,20] },
    { pos: [10,2,0],  size:[0.5,4,20] }
  ];
  walls.forEach(w=>{
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMaterial);
    mesh.position.set(...w.pos);
    scene.add(mesh);
  });

  // LumiÃ¨res
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 10, 7);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x404040));

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);
  window.addEventListener('resize', onWindowResize);

  document.addEventListener('pointerlockchange', () => {
    pointerLocked = (document.pointerLockElement === document.body);
    if (pointerLocked) document.getElementById('overlay').style.display = 'none';
  });

  document.addEventListener('mousemove', onMouseMove);

  // Activer pointer lock au premier mouvement ou touche
  const startGame = () => {
    if (!pointerLocked) {
      document.body.requestPointerLock();
    }
  };
  document.getElementById('overlay').addEventListener('click', startGame);
  document.addEventListener('keydown', startGame, { once: true });
  document.addEventListener('mousemove', startGame, { once: true });
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onKeyDown(event) {
  switch(event.key.toLowerCase()) {
    case 'z': moveForward = true; break;
    case 's': moveBackward = true; break;
    case 'q': moveLeft = true; break;
    case 'd': moveRight = true; break;
  }
}

function onKeyUp(event) {
  switch(event.key.toLowerCase()) {
    case 'z': moveForward = false; break;
    case 's': moveBackward = false; break;
    case 'q': moveLeft = false; break;
    case 'd': moveRight = false; break;
  }
}

let PI_2 = Math.PI / 2;
function onMouseMove(event) {
  if (!pointerLocked) return;
  let movementX = event.movementX || 0;
  let movementY = event.movementY || 0;
  yawObject.rotation.y -= movementX * 0.002;
  pitchObject.rotation.x -= movementY * 0.002;
  pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
}

function animate() {
  requestAnimationFrame(animate);
  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  velocity.set(0, 0, 0);

  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
  forward.y = 0; forward.normalize();
  const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  if (moveForward) velocity.add(forward);
  if (moveBackward) velocity.sub(forward);
  if (moveRight) velocity.add(right);
  if (moveLeft) velocity.sub(right);

  if (velocity.length() > 0) velocity.normalize().multiplyScalar(5 * delta);

  const nextPos = yawObject.position.clone().add(velocity);
  const limit = 9.5;
  if (Math.abs(nextPos.x) < limit && Math.abs(nextPos.z) < limit) {
    yawObject.position.copy(nextPos);
  }

  prevTime = time;
  renderer.render(scene, camera);
}
</script>
</body>
</html>

















