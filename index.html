<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Mini FPS Mobile/PC</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
#joystickContainer {
    position:absolute;
    bottom:50px;
    left:50px;
    width:150px;
    height:150px;
    touch-action:none;
    display:none;
}
#joystick { width:100%; height:100%; border-radius:50%; background:rgba(100,100,100,0.3); position:relative; }
#stick { width:60px; height:60px; background:rgba(200,200,200,0.6); border-radius:50%; position:absolute; left:45px; top:45px; touch-action:none; }
</style>
</head>
<body>
<div id="joystickContainer">
    <div id="joystick">
        <div id="stick"></div>
    </div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

// Scene basique
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,2,5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(50,100,50);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Sol
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(500,500),
    new THREE.MeshStandardMaterial({color:0x228B22})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// Cibles
const targets=[];
const targetMaterial = new THREE.MeshStandardMaterial({color:0xff0000});
function spawnTarget(){
    const t = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), targetMaterial);
    t.position.set(Math.random()*50-25,1,Math.random()*50-25);
    scene.add(t);
    targets.push(t);
}
for(let i=0;i<15;i++) spawnTarget();

// DÃ©tection mobile
const isMobile = /Mobi|Android/i.test(navigator.userAgent);
let move = {forward:false,backward:false,left:false,right:false}, velocity = new THREE.Vector3();

if(isMobile){
    document.getElementById('joystickContainer').style.display='block';
    const stick = document.getElementById('stick');
    let startX, startY, dx=0, dz=0;
    stick.addEventListener('touchstart', e=>{ startX=e.touches[0].clientX; startY=e.touches[0].clientY; });
    stick.addEventListener('touchmove', e=>{
        dx = (e.touches[0].clientX - startX)/50;
        dz = (e.touches[0].clientY - startY)/50;
        dx = Math.max(-1,Math.min(1,dx));
        dz = Math.max(-1,Math.min(1,dz));
    });
    stick.addEventListener('touchend', e=>{ dx=0; dz=0; });
} else {
    document.addEventListener('keydown', e=>{
        if(e.code==='KeyZ') move.forward=true;
        if(e.code==='KeyS') move.backward=true;
        if(e.code==='KeyQ') move.left=true;
        if(e.code==='KeyD') move.right=true;
    });
    document.addEventListener('keyup', e=>{
        if(e.code==='KeyZ') move.forward=false;
        if(e.code==='KeyS') move.backward=false;
        if(e.code==='KeyQ') move.left=false;
        if(e.code==='KeyD') move.right=false;
    });
}

// Tir
const bullets=[];
function shoot(){
    const b = new THREE.Mesh(new THREE.SphereGeometry(0.05,8,8), new THREE.MeshBasicMaterial({color:0xffff00}));
    b.position.copy(camera.position);
    b.direction = new THREE.Vector3();
    camera.getWorldDirection(b.direction);
    bullets.push(b);
    scene.add(b);
}
document.addEventListener('mousedown', shoot);
if(isMobile) document.body.addEventListener('touchstart', shoot);

// Animation
const clock = new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if(isMobile){
        velocity.set(dx*10*delta,0,dz*10*delta);
        camera.translateX(velocity.x);
        camera.translateZ(velocity.z);
    } else {
        velocity.set(0,0,0);
        if(move.forward) velocity.z -= 10*delta;
        if(move.backward) velocity.z += 10*delta;
        if(move.left) velocity.x -= 10*delta;
        if(move.right) velocity.x += 10*delta;
        camera.translateX(velocity.x);
        camera.translateZ(velocity.z);
    }

    bullets.forEach((b,i)=>{
        b.position.addScaledVector(b.direction,10*delta);
        targets.forEach((t,ti)=>{
            if(b.position.distanceTo(t.position)<1){
                scene.remove(t);
                targets.splice(ti,1);
                scene.remove(b);
                bullets.splice(i,1);
            }
        });
    });

    renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>









































