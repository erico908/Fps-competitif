<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>FPS Mobile â€” Joystick Gauche & Cam Droite</title>
<style>
  html,body { margin:0; height:100%; overflow:hidden; background:#202428; }
  canvas { display:block; touch-action:none; }

  /* Zones d'input strictes */
  #joystickZone, #lookZone {
    position:fixed; top:0; height:100vh; z-index:5;
    touch-action:none; /* Ã©vite le scroll/zoom */
  }
  #joystickZone { left:0; width:50vw; }
  #lookZone     { right:0; width:50vw; }

  /* Bouton Tir */
  #shootBtn{
    position:fixed; right:18px; bottom:18px;
    width:88px; height:88px; border-radius:50%;
    background:rgba(255,60,60,.85);
    display:flex; align-items:center; justify-content:center;
    font-size:34px; color:#fff; user-select:none; z-index:6;
    box-shadow:0 6px 18px rgba(0,0,0,.35);
    touch-action:none;
  }

  /* Crosshair (croix) */
  #crosshair{
    position:fixed; left:50%; top:50%;
    width:22px; height:22px; margin-left:-11px; margin-top:-11px;
    pointer-events:none; z-index:7;
  }
  #crosshair:before, #crosshair:after{
    content:""; position:absolute; background:#ffffff;
    opacity:.9;
  }
  #crosshair:before{ left:10px; top:0; width:2px; height:22px; }
  #crosshair:after { left:0; top:10px; width:22px; height:2px; }

  /* Aide visuelle (optionnel) â€“ commente si tu veux */
  .hint { position:fixed; left:10px; top:10px; color:#9fb0c5; font:12px/1.3 system-ui; z-index:8; opacity:.8; }
</style>
</head>
<body>
<div id="joystickZone"></div>
<div id="lookZone"></div>
<div id="shootBtn">ðŸ”¥</div>
<div id="crosshair"></div>
<div class="hint">Gauche: joystick â€” Droite: regarder â€” ðŸ”¥: tirer</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

<script>
// -------------------- SCÃˆNE / RENDER --------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87c7f3);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// -------------------- CAMÃ‰RA avec Yaw/Pitch --------------------
const CAM_HEIGHT = 1.62;
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1200);

const pitch = new THREE.Object3D();   // rotation verticale
pitch.add(camera);
const yaw = new THREE.Object3D();     // rotation horizontale + position
yaw.position.set(0, CAM_HEIGHT, 8);
yaw.add(pitch);
scene.add(yaw);

// Limite du pitch (pas de POV sol)
const PITCH_LIMIT = THREE.MathUtils.degToRad(85);

// -------------------- LUMIÃˆRES --------------------
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(6,10,4);
const amb = new THREE.AmbientLight(0x99aabb, .6);
scene.add(sun, amb);

// -------------------- MAP SIMPLE (style salle) --------------------
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(80,80),
  new THREE.MeshStandardMaterial({ color:0x3a3f46, roughness:.95, metalness:0 })
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ color:0x6d7785, roughness:.9 });
function wall(w,h,d,x,z,ry=0){
  const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
  m.position.set(x, h/2, z);
  m.rotation.y = ry;
  m.castShadow = false; m.receiveShadow = true;
  scene.add(m);
}
wall(80,4,1, 0, -40); // nord
wall(80,4,1, 0,  40); // sud
wall(1, 4,80,-40,  0); // ouest
wall(1, 4,80, 40,  0); // est

// Obstacles basiques
for(let i=0;i<8;i++){
  const box = new THREE.Mesh(
    new THREE.BoxGeometry(2+Math.random()*3, 1+Math.random()*1.5, 2+Math.random()*3),
    new THREE.MeshStandardMaterial({ color:0x888f99 })
  );
  box.position.set((Math.random()-0.5)*60, box.geometry.parameters.height/2, (Math.random()-0.5)*60);
  scene.add(box);
}

// -------------------- CIBLES --------------------
const targets = [];
const targetMat = new THREE.MeshStandardMaterial({ color:0xff3b3b, roughness:.7 });
for (let i=0;i<20;i++){
  const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1,24), targetMat.clone());
  t.position.set((Math.random()-0.5)*60, 0.5, (Math.random()-0.5)*60);
  scene.add(t); targets.push(t);
}

// -------------------- MAINS + AK-47 (lowpoly, proportions rÃ©alistes) --------------------
const fpGroup = new THREE.Group(); // groupe mains+arme attachÃ© Ã  la camÃ©ra
camera.add(fpGroup);
fpGroup.position.set(0, -0.22, -0.55);
// fpGroup.rotation.set(THREE.MathUtils.degToRad(-4), 0, 0); <-- enlevÃ© pour avoir arme droite (modif demandÃ©e)
fpGroup.rotation.set(0,0,0); // **AK-47 tenue droite** (changement demandÃ©)

// Mains (lowpoly)
const skin = new THREE.MeshStandardMaterial({ color:0xffd1a4, roughness:.8 });
const leftHand  = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.12,0.22), skin);
const rightHand = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.12,0.22), skin);
leftHand.position.set(-0.16, -0.02, -0.08);
rightHand.position.set( 0.12, -0.02, -0.05);
fpGroup.add(leftHand, rightHand);

// AK-47 stylisÃ©e (barrel + handguard + receiver + mag + stock + sights)
const steel = new THREE.MeshStandardMaterial({ color:0x222222, roughness:.6, metalness:.4 });
const wood  = new THREE.MeshStandardMaterial({ color:0x8b4513, roughness:.8, metalness:0 });

const ak = new THREE.Group();
fpGroup.add(ak);

// canon
const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.55, 12), steel);
barrel.rotation.z = Math.PI/2; barrel.position.set(0.15, -0.02, 0.0);
ak.add(barrel);

// garde-main
const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.30,0.06,0.09), wood);
handguard.position.set(0.03, -0.02, 0.0);
ak.add(handguard);

// corps/culasse
const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.09,0.08), steel);
receiver.position.set(-0.17, -0.01, 0.0);
ak.add(receiver);

// chargeur courbÃ©
const mag = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,0.24, 10, 1, true, 0, Math.PI), steel);
mag.rotation.set(0,0,Math.PI/2);
mag.position.set(-0.1, -0.12, 0.03);
ak.add(mag);

// crosse
const stock = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.09,0.08), wood);
stock.position.set(-0.33, -0.02, 0.0);
ak.add(stock);

// organes de visÃ©e
const sightRear = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.03,0.02), steel);
sightRear.position.set(-0.12, 0.02, 0);
const sightFront = new THREE.Mesh(new THREE.BoxGeometry(0.03,0.04,0.02), steel);
sightFront.position.set(0.30, 0.01, 0);
ak.add(sightRear, sightFront);

// lÃ©gÃ¨re position mains vs arme
// --- ajustÃ© Z des mains pour enlever le "truc beige" visible au niveau de la gÃ¢chette (modif demandÃ©e) ---
leftHand.position.set(-0.06, -0.04, -0.12);
rightHand.position.set(-0.19, -0.05, -0.12);

// -------------------- CONTRÃ”LES MOBILE --------------------

// JOYSTICK : uniquement dans la zone gauche
const joystick = nipplejs.create({
  zone: document.getElementById('joystickZone'),
  mode: 'dynamic',
  color: 'deepskyblue',
  multitouch: false,
  size: 110
});

let moveX = 0, moveZ = 0; // -1..1
joystick.on('move', (evt, data) => {
  // vecteur dÃ©jÃ  normalisÃ© par nipplejs
  moveX = data.vector.x;      
  moveZ = data.vector.y;     // **changement : suppression du - pour corriger haut/bas (haut = avancer)**
});
joystick.on('end', () => { moveX = 0; moveZ = 0; });

// LOOK : uniquement dans la zone droite (camÃ©ra FPS)
let lookId = null, lastX = 0, lastY = 0;
const lookZone = document.getElementById('lookZone');

const SENS_X = 0.0038; // sensibilitÃ© horizontale
const SENS_Y = 0.0032; // sensibilitÃ© verticale (pitch)

lookZone.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  const t = e.changedTouches[0];
  lookId = t.identifier; lastX = t.pageX; lastY = t.pageY;
}, {passive:false});

lookZone.addEventListener('touchmove', (e)=>{
  if(lookId===null) return;
  for (const t of e.changedTouches){
    if (t.identifier === lookId){
      const dx = t.pageX - lastX;
      const dy = t.pageY - lastY;
      // Rotation FPS: yaw (y), pitch (x)
      yaw.rotation.y -= dx * SENS_X;
      pitch.rotation.x -= dy * SENS_Y;
      // Clamp pitch
      pitch.rotation.x = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch.rotation.x));
      lastX = t.pageX; lastY = t.pageY;
      break;
    }
  }
}, {passive:false});

lookZone.addEventListener('touchend', (e)=>{
  for(const t of e.changedTouches){
    if(t.identifier===lookId){ lookId = null; break; }
  }
});

// -------------------- TIR : balles visibles + flash --------------------
const bullets = [];
const bulletGeo = new THREE.SphereGeometry(0.025, 10, 10);
const bulletMat = new THREE.MeshBasicMaterial({ color:0xffe14d });

function shoot(){
  // position Ã  l'embouchure du canon
  const muzzle = new THREE.Vector3();
  barrel.getWorldPosition(muzzle);

  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();

  const b = new THREE.Mesh(bulletGeo, bulletMat);
  b.position.copy(muzzle);
  b.userData.vel = dir.clone().multiplyScalar(1.2); // vitesse
  b.userData.life = 2.2; // secondes
  bullets.push(b);
  scene.add(b);

  // Muzzle flash trÃ¨s bref
  const flash = new THREE.PointLight(0xffaa33, 2.2, 2.5);
  flash.position.copy(muzzle);
  scene.add(flash);
  setTimeout(()=>scene.remove(flash), 45);
}

const shootBtn = document.getElementById('shootBtn');
shootBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); shoot(); }, {passive:false});
shootBtn.addEventListener('mousedown', (e)=>{ e.preventDefault(); shoot(); });

// -------------------- BOUCLE --------------------
const clock = new THREE.Clock();
const SPEED = 6.0; // m/s approx

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.033);

  // DÃ©placement basÃ© sur le yaw (orientation horizontale)
  // Vecteurs monde Ã  partir du yaw (pas du pitch).
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(yaw.quaternion); forward.y = 0; forward.normalize();
  const right   = new THREE.Vector3(1,0, 0).applyQuaternion(yaw.quaternion); right.y = 0; right.normalize();

  // Stick â†’ avant/arriÃ¨re (moveZ), gauche/droite (moveX)
  yaw.position.add(forward.multiplyScalar(moveZ * SPEED * dt));
  yaw.position.add(right.multiplyScalar(  moveX * SPEED * dt));

  // Verrouille la hauteur (pas de POV sol)
  yaw.position.y = CAM_HEIGHT;

  // Mises Ã  jour des balles (collision naÃ¯ve avec cibles)
  for (let i = bullets.length-1; i>=0; i--){
    const b = bullets[i];
    b.position.addScaledVector(b.userData.vel, dt / (1/60)); // homogÃ©nÃ©iser vitesse
    b.userData.life -= dt;
    // hit test simple
    let hit = false;
    for (let j=targets.length-1; j>=0; j--){
      const t = targets[j];
      if (b.position.distanceTo(t.position) < 0.6){
        t.material.color.set(0x69ff69);
        hit = true; break;
      }
    }
    if (hit || b.userData.life <= 0){
      scene.remove(b); bullets.splice(i,1);
    }
  }

  renderer.render(scene, camera);
}
animate();

// -------------------- RESIZE --------------------
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>


















