<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FPS Prototype Partie 1</title>
<style>
/* Styles globaux */
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #0a0a0a;
    font-family: Arial, sans-serif;
}

/* Overlay de démarrage */
#overlay {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.85);
    color: white;
}

#overlay h1 {
    font-size: 28px;
    margin-bottom: 20px;
}

#overlay button {
    padding: 12px 20px;
    border-radius: 12px;
    border: none;
    background: #111;
    color: white;
    font-weight: bold;
    cursor: pointer;
}

#overlay button:hover {
    background: #222;
}
</style>
</head>
<body>
<!-- Overlay de démarrage -->
<div id="overlay">
<h1>Modern Combat Prototype</h1>
<button id="start">Commencer</button>
</div>

<!-- Scripts Three.js -->
<script type="module">
// ---------------- Import des modules ----------------
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/PointerLockControls.js';
import { EffectComposer } from 'https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { SSAOPass } from 'https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/SSAOPass.js';

// ---------------- Renderer ----------------
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ---------------- Scene ----------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0d11);

// ---------------- Camera ----------------
const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    2000
);
camera.position.set(0, 1.6, 5);

// ---------------- Controls ----------------
const controls = new PointerLockControls(camera, document.body);
const overlay = document.getElementById('overlay');
document.getElementById('start').addEventListener('click', ()=> controls.lock());
controls.addEventListener('lock', ()=> overlay.style.display = 'none');
controls.addEventListener('unlock', ()=> overlay.style.display = 'flex');

// ---------------- Resize ----------------
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
// ---------------- Lumières ----------------

// Lumière hémisphérique (sky + ground)
const hemiLight = new THREE.HemisphereLight(0xb1e1ff, 0x1b1b1b, 0.35);
scene.add(hemiLight);

// Lumière directionnelle (soleil)
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(8, 16, 6);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 80;
dirLight.shadow.camera.left = -30;
dirLight.shadow.camera.right = 30;
dirLight.shadow.camera.top = 30;
dirLight.shadow.camera.bottom = -30;
scene.add(dirLight);

// ---------------- Sol ----------------
const groundMat = new THREE.MeshStandardMaterial({
    color: 0x2a2e33,
    roughness: 0.9,
    metalness: 0.05
});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// ---------------- Couvertures / Obstacles ----------------
const coverMat = new THREE.MeshStandardMaterial({
    color: 0x3b4252,
    roughness: 0.75,
    metalness: 0.1
});

const covers = []; // tableau pour stocker les obstacles

for (let i = 0; i < 20; i++) {
    const cover = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), coverMat);
    cover.position.set(
        (Math.random() - 0.5) * 80, // X aléatoire
        1,                          // Y fixe (demi-hauteur du cube)
        (Math.random() - 0.5) * 80  // Z aléatoire
    );
    cover.castShadow = true;
    cover.receiveShadow = true;
    scene.add(cover);
    covers.push(cover);
}

// ---------------- Boucle de rendu simple ----------------
function animatePart2() {
    requestAnimationFrame(animatePart2);
    renderer.render(scene, camera);
}
animatePart2();
// ---------------- Variables Player ----------------
let velocity = new THREE.Vector3(); // vitesse actuelle
let direction = new THREE.Vector3(); // direction du mouvement
let onGround = true;                 // indique si le joueur touche le sol

const speed = 7.2;        // vitesse normale
const sprintMultiplier = 1.45; // multiplicateur de sprint
const jumpVelocity = 8.5; // force de saut
const gravity = -22;      // gravité globale

// ---------------- Gestion du clavier ----------------
const keys = new Set();

window.addEventListener('keydown', (event) => keys.add(event.code));
window.addEventListener('keyup', (event) => keys.delete(event.code));

// ---------------- Fonction de mise à jour player ----------------
function updatePlayer(dt) {
    // Réinitialisation direction
    direction.set(0, 0, 0);

    // Récupération des axes avant/arrière et gauche/droite
    if (keys.has('KeyW')) direction.z -= 1;
    if (keys.has('KeyS')) direction.z += 1;
    if (keys.has('KeyA')) direction.x -= 1;
    if (keys.has('KeyD')) direction.x += 1;

    // Normalisation pour éviter d'aller plus vite en diagonale
    if (direction.length() > 0) direction.normalize();

    // Application du sprint
    const moveSpeed = keys.has('ShiftLeft') ? speed * sprintMultiplier : speed;

    // Calcul des vitesses X et Z
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    const right = new THREE.Vector3();
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate().normalize();

    velocity.x = THREE.MathUtils.damp(velocity.x, direction.x * moveSpeed, 10, dt);
    velocity.z = THREE.MathUtils.damp(velocity.z, direction.z * moveSpeed, 10, dt);

    // Gravité et saut
    velocity.y += gravity * dt;
    if (onGround && keys.has('Space')) {
        velocity.y = jumpVelocity;
        onGround = false;
    }

    // Déplacement de la caméra
    camera.position.addScaledVector(forward, velocity.z * dt);
    camera.position.addScaledVector(right, velocity.x * dt);
    camera.position.y += velocity.y * dt;

    // Collision sol
    if (camera.position.y < 1.6) {
        camera.position.y = 1.6;
        velocity.y = 0;
        onGround = true;
    }

    // Limites terrain (pour rester dans le sol)
    camera.position.x = THREE.MathUtils.clamp(camera.position.x, -190, 190);
    camera.position.z = THREE.MathUtils.clamp(camera.position.z, -190, 190);
}

// ---------------- Boucle principale ----------------
let lastTime = performance.now();

function animatePart3() {
    requestAnimationFrame(animatePart3);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
    }

    renderer.render(scene, camera);
}

animatePart3();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
// ---------------- HUD ----------------
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.left = '50%';
crosshair.style.top = '50%';
crosshair.style.width = '12px';
crosshair.style.height = '12px';
crosshair.style.marginLeft = '-6px';
crosshair.style.marginTop = '-6px';
crosshair.style.border = '2px solid white';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

const ammoEl = document.createElement('div');
ammoEl.style.position = 'absolute';
ammoEl.style.left = '16px';
ammoEl.style.bottom = '16px';
ammoEl.style.color = 'white';
ammoEl.style.fontFamily = 'sans-serif';
ammoEl.style.fontSize = '14px';
ammoEl.textContent = 'Munitions : 30';
document.body.appendChild(ammoEl);

let ammo = 30;

// ---------------- Tir avec raycaster ----------------
const raycaster = new THREE.Raycaster();

function fire() {
    if (!controls.isLocked) return;
    if (ammo <= 0) return;
    ammo--;
    ammoEl.textContent = 'Munitions : ' + ammo;

    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(covers, false);
    if (intersects.length > 0) {
        // Hitmarker
        crosshair.style.borderColor = 'red';
        setTimeout(() => crosshair.style.borderColor = 'white', 100);
    }
}

window.addEventListener('mousedown', fire);

// ---------------- Ennemis simples ----------------
const enemies = [];

function spawnEnemy() {
    const mat = new THREE.MeshStandardMaterial({ color: 0xb34d4d, roughness: 0.6, metalness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 1.2), mat);
    mesh.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
    mesh.castShadow = true;
    scene.add(mesh);
    enemies.push({ mesh, hp: 100 });
}

for (let i = 0; i < 5; i++) spawnEnemy();

function enemyAI(dt) {
    const camPos = camera.position.clone();
    enemies.forEach(e => {
        const toPlayer = camPos.clone().sub(e.mesh.position);
        const dist = toPlayer.length();
        if (dist < 15) {
            toPlayer.normalize();
            e.mesh.position.addScaledVector(toPlayer, 2 * dt);
        }
    });
}

// ---------------- Mise à jour dans la boucle ----------------
function animatePart4() {
    requestAnimationFrame(animatePart4);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (controls.isLocked) {
        updatePlayer(dt);
        enemyAI(dt);
    }

    renderer.render(scene, camera);
}

animatePart4();
































