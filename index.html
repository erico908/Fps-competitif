<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>FPS simple avec mouvement corrigé</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; }
  #info {
    position: absolute; top: 10px; left: 10px; 
    color: white; background: rgba(0,0,0,0.5); 
    padding: 8px; font-family: Arial, sans-serif;
    z-index: 10;
  }
</style>
</head>
<body>
<div id="info">Clique dans la page, puis bouge la souris pour tourner. Utilise Z/S/Q/D pour te déplacer.</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
let camera, scene, renderer;
let pitchObject, yawObject;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let canJump = false;
let prevTime = performance.now();
let pointerLocked = false;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  pitchObject = new THREE.Object3D();
  pitchObject.add(camera);

  yawObject = new THREE.Object3D();
  yawObject.position.y = 2;
  yawObject.add(pitchObject);

  scene.add(yawObject);

  // Sol vert
  const floorGeometry = new THREE.PlaneGeometry(20, 20);
  const floorMaterial = new THREE.MeshPhongMaterial({color: 0x228B22});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Murs
  const wallGeometry = new THREE.BoxGeometry(20, 4, 0.5);
  const wallMaterial1 = new THREE.MeshPhongMaterial({color: 0x8B4513});
  const wallMaterial2 = new THREE.MeshPhongMaterial({color: 0xA0522D});
  const backWall = new THREE.Mesh(wallGeometry, wallMaterial1);
  backWall.position.set(0, 2, -10);
  scene.add(backWall);

  const frontWall = new THREE.Mesh(wallGeometry, wallMaterial2);
  frontWall.position.set(0, 2, 10);
  scene.add(frontWall);

  const sideWallGeometry = new THREE.BoxGeometry(0.5, 4, 20);
  const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial1);
  leftWall.position.set(-10, 2, 0);
  scene.add(leftWall);

  const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial2);
  rightWall.position.set(10, 2, 0);
  scene.add(rightWall);

  // Lumières
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 10, 7);
  scene.add(light);
  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Pointer lock
  document.body.addEventListener('click', () => {
    if (!pointerLocked) {
      document.body.requestPointerLock();
    }
  });

  document.addEventListener('pointerlockchange', () => {
    pointerLocked = (document.pointerLockElement === document.body);
  });

  // Rotation caméra
  document.addEventListener('mousemove', (event) => {
    if (!pointerLocked) return;
    const movementX = event.movementX || 0;
    const movementY = event.movementY || 0;

    yawObject.rotation.y -= movementX * 0.002;
    pitchObject.rotation.x -= movementY * 0.002;

    const PI_2 = Math.PI / 2;
    pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
  });

  // Clavier
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onKeyDown(event) {
  switch(event.code) {
    case 'KeyZ': moveForward = true; break;
    case 'KeyS': moveBackward = true; break;
    case 'KeyQ': moveLeft = true; break;
    case 'KeyD': moveRight = true; break;
    case 'Space': 
      if(canJump) {
        velocity.y += 10;
        canJump = false;
      }
      break;
  }
}

function onKeyUp(event) {
  switch(event.code) {
    case 'KeyZ': moveForward = false; break;
    case 'KeyS': moveBackward = false; break;
    case 'KeyQ': moveLeft = false; break;
    case 'KeyD': moveRight = false; break;
  }
}

function animate() {
  requestAnimationFrame(animate);

  const time = performance.now();
  const delta = (time - prevTime) / 1000;

  velocity.x -= velocity.x * 10.0 * delta;
  velocity.z -= velocity.z * 10.0 * delta;
  velocity.y -= 9.8 * 5.0 * delta;

  direction.z = Number(moveForward) - Number(moveBackward);
  direction.x = Number(moveRight) - Number(moveLeft);
  direction.normalize();

  if (moveForward || moveBackward) velocity.z -= direction.z * 50.0 * delta;
  if (moveLeft || moveRight) velocity.x -= direction.x * 50.0 * delta;

  // Calcul déplacement en fonction de la rotation Y de la caméra
  const angle = yawObject.rotation.y;
  const forward = new THREE.Vector3(-Math.sin(angle), 0, -Math.cos(angle));
  const right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));

  // Appliquer déplacement selon direction et rotation caméra
  yawObject.position.addScaledVector(forward, velocity.z * delta);
  yawObject.position.addScaledVector(right, velocity.x * delta);

  yawObject.position.y += velocity.y * delta;

  if(yawObject.position.y < 2) {
    velocity.y = 0;
    yawObject.position.y = 2;
    canJump = true;
  }

  prevTime = time;

  renderer.render(scene, camera);
}
</script>
</body>
</html>







