<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>FPS – ZQSD + Caméra (PointerLockControls, fallback)</title>
  <style>
    :root{ --ui: rgba(0,0,0,.55); }
    html,body{height:100%}
    body{ margin:0; overflow:hidden; background:#000 }
    canvas{ display:block }
    #instructions{
      position:absolute; inset:auto auto 16px 16px; color:#fff; font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; z-index:100; background:var(--ui); padding:10px 12px; border-radius:10px; max-width:360px; user-select:none;
    }
    #status{ display:inline-block; margin-top:6px; padding:2px 6px; border-radius:6px; font-size:12px; background:#2c7; color:#041 }
  </style>
</head>
<body>
<div id="instructions">
  <div style="font-weight:700; margin-bottom:6px">Contrôles</div>
  Z / S : Avancer / Reculer<br/>
  Q / D : Gauche / Droite<br/>
  Souris : Regarder (sans clic)<br/>
  Esc : Libérer la souris
  <div id="status">Init…</div>
</div>

<!-- Three.js + Controls (open source MIT) -->
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
  import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/controls/PointerLockControls.js';

  let camera, scene, renderer, controls;
  let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();
  let prevTime = performance.now();

  const SPEED = 5; // m/s

  const statusEl = document.getElementById('status');

  init();
  animate();

  function init(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // ciel bleu

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    // Lumières
    const dir = new THREE.DirectionalLight(0xffffff, 1); dir.position.set(5,10,7); scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    // Sol
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshPhongMaterial({color:0x228B22}));
    floor.rotation.x = -Math.PI/2; scene.add(floor);

    // Murs (carré 20x20, 4 de haut)
    const wallMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
    scene.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(20,4,0.5), wallMat), { position: new THREE.Vector3(0,2,-10) }));
    scene.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(20,4,0.5), wallMat), { position: new THREE.Vector3(0,2, 10) }));
    scene.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.5,4,20), wallMat), { position: new THREE.Vector3(-10,2,0) }));
    scene.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.5,4,20), wallMat), { position: new THREE.Vector3( 10,2,0) }));

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Camera Controls (open source): PointerLockControls ---
    controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());
    controls.getObject().position.set(0, 2, 0); // hauteur "oeil"

    // Essayer de locker automatiquement, avec garde-fous si non supporté
    const canLock = !!(document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock);
    if (canLock) {
      try{ controls.lock(); }catch(e){ console.warn('PointerLock auto refusé:', e); }
      statusEl.textContent = 'Pointer Lock prêt (auto)';
      controls.addEventListener('lock', ()=> statusEl.textContent = 'Pointer Lock: actif');
      controls.addEventListener('unlock', ()=> statusEl.textContent = 'Pointer Lock: inactif');
    } else {
      statusEl.textContent = 'Sans Pointer Lock (drag actif)';
      enableDragLookFallback();
    }

    // Clavier ZQSD
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    window.addEventListener('resize', onWindowResize);

    // Diagnostics ("tests")
    console.assert(!!THREE && !!renderer && !!controls, 'Init OK');
    console.assert(typeof controls.moveForward === 'function', 'PointerLockControls chargé');
  }

  function enableDragLookFallback(){
    let dragging=false, lastX=0, lastY=0; const SENS=0.0025; const PI_2 = Math.PI/2;
    const euler = new THREE.Euler(0,0,0,'YXZ');

    const onMove = (dx,dy)=>{
      euler.setFromQuaternion(camera.quaternion);
      euler.y -= dx * SENS; // yaw
      euler.x -= dy * SENS; // pitch
      euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
      camera.quaternion.setFromEuler(euler);
    };

    document.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
    document.addEventListener('mouseup',   ()=>{ dragging=false; });
    document.addEventListener('mousemove', e=>{ if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; onMove(dx,dy); });

    document.addEventListener('touchstart', e=>{ if(e.touches.length!==1) return; dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; }, {passive:true});
    document.addEventListener('touchend',   ()=>{ dragging=false; }, {passive:true});
    document.addEventListener('touchmove',  e=>{ if(!dragging||e.touches.length!==1) return; const t=e.touches[0]; const dx=t.clientX-lastX, dy=t.clientY-lastY; lastX=t.clientX; lastY=t.clientY; onMove(dx,dy); }, {passive:true});
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onKeyDown(e){
    switch(e.key.toLowerCase()){
      case 'z': moveForward = true; break;
      case 's': moveBackward = true; break;
      case 'q': moveLeft = true; break;
      case 'd': moveRight = true; break;
    }
  }
  function onKeyUp(e){
    switch(e.key.toLowerCase()){
      case 'z': moveForward = false; break;
      case 's': moveBackward = false; break;
      case 'q': moveLeft = false; break;
      case 'd': moveRight = false; break;
    }
  }

  function animate(){
    requestAnimationFrame(animate);

    const time = performance.now();
    const delta = (time - prevTime) / 1000;

    // Déplacement via PointerLockControls
    direction.set(0,0,0);
    direction.z = (moveForward?1:0) - (moveBackward?1:0);
    direction.x = (moveRight?1:0) - (moveLeft?1:0);
    if (direction.lengthSq() > 0) direction.normalize();

    const step = SPEED * delta;
    if (direction.z !== 0) controls.moveForward( step * direction.z );
    if (direction.x !== 0) controls.moveRight(   step * direction.x );

    // Limites carte
    const p = controls.getObject().position;
    const limit = 9.5;
    p.x = Math.max(-limit, Math.min(limit, p.x));
    p.z = Math.max(-limit, Math.min(limit, p.z));

    prevTime = time;
    renderer.render(scene, camera);
  }
</script>
</body>
</html>














