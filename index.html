<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>FPS Style CS:GO Simple</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

// Scene et caméra
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // ciel bleu

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,2,5);

// Renderer
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lumière
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(50,100,50);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Sol
const floorMat = new THREE.MeshStandardMaterial({color:0x808080});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// Murs style CS:GO
const wallMat = new THREE.MeshStandardMaterial({color:0x555555});
const walls = [];
function addWall(x,y,z,w,h,d){
    const wall = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
    wall.position.set(x,y,z);
    scene.add(wall);
    walls.push(wall);
}

// Crée des murs autour de la map
addWall(0,2.5,-50,100,5,1); // fond
addWall(0,2.5,50,100,5,1);  // avant
addWall(-50,2.5,0,1,5,100); // gauche
addWall(50,2.5,0,1,5,100);  // droite

// Obstacles intérieurs
addWall(-10,1,0,5,2,10);
addWall(10,1,5,5,2,10);
addWall(0,1,-10,10,2,5);

// Cibles
const targets = [];
const targetMat = new THREE.MeshStandardMaterial({color:0xff0000});
function spawnTarget(){
    const t = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), targetMat);
    t.position.set(Math.random()*80-40,0.5,Math.random()*80-40);
    scene.add(t);
    targets.push(t);
}
for(let i=0;i<20;i++) spawnTarget();

// Contrôle clavier + souris (FPS)
let move = {forward:false,backward:false,left:false,right:false};
let velocity = new THREE.Vector3();
document.addEventListener('keydown', e=>{
    if(e.code==='KeyZ') move.forward=true;
    if(e.code==='KeyS') move.backward=true;
    if(e.code==='KeyQ') move.left=true;
    if(e.code==='KeyD') move.right=true;
});
document.addEventListener('keyup', e=>{
    if(e.code==='KeyZ') move.forward=false;
    if(e.code==='KeyS') move.backward=false;
    if(e.code==='KeyQ') move.left=false;
    if(e.code==='KeyD') move.right=false;
});

let mouseDown=false, prevX=0, prevY=0;
document.addEventListener('mousedown', ()=>{ mouseDown=true; });
document.addEventListener('mouseup', ()=>{ mouseDown=false; });
document.addEventListener('mousemove', e=>{
    if(!mouseDown) return;
    const dx=(e.clientX-prevX)/200;
    const dy=(e.clientY-prevY)/200;
    camera.rotation.y -= dx;
    camera.rotation.x -= dy;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    prevX = e.clientX; prevY = e.clientY;
});

// Tir simple avec raycast
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
document.addEventListener('mousedown', shoot);
function shoot(e){
    raycaster.setFromCamera({x:0,y:0}, camera);
    const intersects = raycaster.intersectObjects(targets);
    if(intersects.length>0){
        const hit = intersects[0].object;
        scene.remove(hit);
        targets.splice(targets.indexOf(hit),1);
    }
}

// Animation
const clock = new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    // Déplacement
    velocity.set(0,0,0);
    if(move.forward) velocity.z -= 10*delta;
    if(move.backward) velocity.z += 10*delta;
    if(move.left) velocity.x -= 10*delta;
    if(move.right) velocity.x += 10*delta;
    camera.translateX(velocity.x);
    camera.translateZ(velocity.z);

    renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>











































